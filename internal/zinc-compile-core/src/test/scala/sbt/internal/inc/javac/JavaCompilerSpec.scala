/*
 * Zinc - The incremental compiler for Scala.
 * Copyright 2011 - 2017, Lightbend, Inc.
 * Copyright 2008 - 2010, Mark Harrah
 * This software is released under the terms written in LICENSE.
 */

package sbt
package internal
package inc
package javac

import java.io.File
import java.net.URLClassLoader
import java.util.Optional

import xsbt.api.SameAPI
import xsbti.{ Problem, Severity }
import xsbti.compile.{ IncToolOptions, IncToolOptionsUtil, JavaTools => XJavaTools }
import sbt.io.IO
import sbt.util.LogExchange
import org.scalatest.matchers._

class JavaCompilerSpec extends UnitSpec {

  "Compiling a java file with local javac" should "compile a java file" in works(local)
  it should "issue errors and warnings" in findsErrors(local)

  "Compiling a file with forked javac" should "compile a java file" in works(forked, forked = true)
  it should "issue errors and warnings" in findsErrors(forked)
  it should "yield the same errors as local javac" in forkSameAsLocal()

  "Documenting a file with forked javadoc" should "document a java file" in docWorks(forked)
  it should "find errors in a java file" in findsDocErrors(forked)

  "Analyzing classes generated by javac" should "matching APIs for stable static-final fields" in analyzeStaticDifference(
    "String",
    "\"A\"",
    "\"A\"")
  it should "different APIs for static-final fields with changed values" in analyzeStaticDifference(
    "String",
    "\"A\"",
    "\"B\"")
  it should "different APIs for static-final fields with changed types" in analyzeStaticDifference(
    "String",
    "\"1\"",
    "int",
    "1")
  it should "\"safe\" singleton type names " in analyzeStaticDifference("float",
                                                                        "0.123456789f",
                                                                        "0.123456789f")

  def docWorks(compiler: XJavaTools) = IO.withTemporaryDirectory { out =>
    val (result, _) = doc(compiler, Seq(knownSampleGoodFile), Seq("-d", out.getAbsolutePath))
    result shouldBe true
    new File(out, "index.html").exists shouldBe true
    new File(out, "good.html").exists shouldBe true
  }

  def works(compiler: XJavaTools, forked: Boolean = false) = IO.withTemporaryDirectory { out =>
    val classfileManager = new CollectingClassFileManager()
    val (result, _) = compile(
      compiler,
      Seq(knownSampleGoodFile),
      Seq("-deprecation", "-d", out.getAbsolutePath),
      incToolOptions = IncToolOptionsUtil
        .defaultIncToolOptions()
        .withClassFileManager(Optional.of(classfileManager))
        .withUseCustomizedFileManager(true)
    )

    result shouldBe true
    val classfile = new File(out, "good.class")
    classfile.exists shouldBe true
    classfileManager.generatedClasses shouldEqual (if (forked) Set() else Set(classfile))

    val cl = new URLClassLoader(Array(out.toURI.toURL))
    val clazzz = cl.loadClass("good")
    val mthd = clazzz.getDeclaredMethod("test")
    mthd.invoke(null) shouldBe "Hello"
  }

  def findsErrors(compiler: XJavaTools) = {
    val (result, problems) = compile(compiler, Seq(knownSampleErrorFile), Seq("-deprecation"))
    result shouldBe false
    problems should have size 5
    val importWarn = warnOnLine(lineno = 1, lineContent = Some("java.rmi.RMISecurityException"))
    val beAnExpectedError = List(importWarn, errorOnLine(3), errorOnLine(4), warnOnLine(7)) reduce (_ or _)
    problems foreach (_ should beAnExpectedError)
  }

  def findsDocErrors(compiler: XJavaTools) = IO.withTemporaryDirectory { out =>
    val (result, problems) =
      doc(compiler, Seq(knownSampleErrorFile), Seq("-d", out.getAbsolutePath))
    result shouldBe true
    problems should have size 2
    val beAnExpectedError = List(errorOnLine(3), errorOnLine(4)) reduce (_ or _)
    problems foreach (_ should beAnExpectedError)
  }

  /**
   * Compiles with the given constant values, and confirms that if the strings mismatch, then the
   * the APIs mismatch.
   */
  def analyzeStaticDifference(typeName: String, left: String, right: String): Unit =
    analyzeStaticDifference(typeName, left, typeName, right)

  def analyzeStaticDifference(leftType: String,
                              left: String,
                              rightType: String,
                              right: String): Unit = {
    def compileWithPrimitive(templateType: String, templateValue: String) =
      IO.withTemporaryDirectory { out =>
        // copy the input file to a temporary location and change the templateValue
        val input = new File(out, hasStaticFinalFile.getName)
        IO.writeLines(
          input,
          IO.readLines(hasStaticFinalFile).map { line =>
            line.replace("TYPE", templateType).replace("VALUE", templateValue)
          }
        )

        // then compile it
        val (result, _) = compile(local, Seq(input), Seq("-d", out.getAbsolutePath))
        result shouldBe true
        val clazzz = new URLClassLoader(Array(out.toURI.toURL)).loadClass("hasstaticfinal")
        ClassToAPI(Seq(clazzz))
      }

    // compile with two different primitive values, and confirm that they match if their
    // values match
    val leftAPI = compileWithPrimitive(leftType, left)
    val rightAPI = compileWithPrimitive(rightType, right)
    leftAPI.size shouldBe rightAPI.size
    ((leftAPI, rightAPI).zipped forall SameAPI.apply) shouldBe (left == right)
    ()
  }

  def lineMatches(p: Problem, lineno: Int, lineContent: Option[String] = None): Boolean = {
    def lineContentCheck =
      lineContent match {
        case Some(content) => p.position.lineContent contains content
        case _             => true
      }
    def lineNumberCheck = p.position.line.isPresent && (p.position.line.get == lineno)
    lineNumberCheck && lineContentCheck
  }

  def isError(p: Problem): Boolean = p.severity == Severity.Error
  def isWarn(p: Problem): Boolean = p.severity == Severity.Warn

  def errorOnLine(lineno: Int, lineContent: Option[String] = None) =
    Matcher { (p: Problem) =>
      MatchResult(
        lineMatches(p, lineno, lineContent) && isError(p),
        s"Expected error on line $lineno with content = '$lineContent', but found $p",
        "Problem matched: " + p
      )
    }
  def warnOnLine(lineno: Int, lineContent: Option[String] = None) =
    Matcher { (p: Problem) =>
      MatchResult(
        lineMatches(p, lineno, lineContent) && isWarn(p),
        s"Expected warning on line $lineno with content = '$lineContent', but found $p",
        "Problem matched: " + p
      )
    }

  def forkSameAsLocal() = {
    val (fresult, fproblems) = compile(forked, Seq(knownSampleErrorFile), Seq("-deprecation"))
    val (lresult, lproblems) = compile(local, Seq(knownSampleErrorFile), Seq("-deprecation"))
    fresult shouldBe lresult

    (fproblems zip lproblems) foreach {
      case (f, l) =>
        // TODO - We should check to see if the levenshtein distance of the messages is close...
        if (f.position.sourcePath.isPresent)
          f.position.sourcePath.get shouldBe l.position.sourcePath.get
        else l.position.sourcePath.isPresent shouldBe false

        if (f.position.line.isPresent) f.position.line.get shouldBe l.position.line.get
        else l.position.line.isPresent shouldBe false

        f.severity shouldBe l.severity
    }
  }

  def compile(c: XJavaTools,
              sources: Seq[File],
              args: Seq[String],
              incToolOptions: IncToolOptions = IncToolOptionsUtil.defaultIncToolOptions())
    : (Boolean, Array[Problem]) = {
    val log = LogExchange.logger("JavaCompilerSpec")
    val reporter = new ManagedLoggedReporter(10, log)
    val result = c.javac.run(sources.toArray, args.toArray, incToolOptions, reporter, log)
    (result, reporter.problems)
  }

  def doc(c: XJavaTools,
          sources: Seq[File],
          args: Seq[String],
          incToolOptions: IncToolOptions = IncToolOptionsUtil.defaultIncToolOptions())
    : (Boolean, Array[Problem]) = {
    val log = LogExchange.logger("JavaCompilerSpec")
    val reporter = new ManagedLoggedReporter(10, log)
    val result = c.javadoc.run(sources.toArray, args.toArray, incToolOptions, reporter, log)
    (result, reporter.problems)
  }

  // TODO - Create one with known JAVA HOME.
  def forked = JavaTools(JavaCompiler.fork(), Javadoc.fork())

  def local =
    JavaTools(
      JavaCompiler.local.getOrElse(sys.error("This test cannot be run on a JRE, but only a JDK.")),
      Javadoc.local.getOrElse(Javadoc.fork())
    )

  def cwd =
    new File(new File(".").getAbsolutePath).getCanonicalFile

  def knownSampleErrorFile =
    new java.io.File(getClass.getResource("test1.java").toURI)

  def knownSampleGoodFile =
    new java.io.File(getClass.getResource("good.java").toURI)

  def hasStaticFinalFile =
    new java.io.File(getClass.getResource("hasstaticfinal.java").toURI)

}
